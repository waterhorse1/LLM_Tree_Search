{
    "summary": "The function handles variable-length inputs and validates padding sides, while the code defines a class for managing data with methods to add/clear experiences, retrieve items by index, and create DataLoader objects.",
    "details": [
        {
            "comment": "This function collates a sequence of TimeStep elements into an MCTSBatch. It uses pad_sequence to handle padding, depending on the 'padding_side' argument. If 'padding_side' is 'left', it pads the start of each query tensor; if 'right', it pads the end of each query tensor. Raises ValueError for invalid padding side.",
            "location": "\"/media/root/Toshiba XG3/works/LLM_Tree_Search/docs/src/tsllm/rl/data/buffer.py\":0-31",
            "content": "from typing import List, Sequence\nimport torch\nimport torch.nn.functional as F\nfrom torch.utils.data import Dataset, DataLoader\nfrom tsllm.distributed.utils import print_with_rank\nfrom tsllm.rl.data.node_types import TimeStep, Trajectory, MCTSBatch\nfrom functools import partial\nfrom torch.nn.utils.rnn import pad_sequence\ndef collate_fn(\n    padding_side: str,\n    pad_token_id: int,\n    max_action_length: int,\n    max_num_actions: int,\n    elems: Sequence[TimeStep],\n) -> MCTSBatch:\n    if padding_side == \"left\":\n        # Left padding of already left-padded queries\n        query_tensors = pad_sequence(\n            [elem.query_tensor.flip(0) for elem in elems],\n            padding_value=pad_token_id,\n            batch_first=True,\n        ).flip(1)\n    elif padding_side == \"right\":\n        query_tensors = pad_sequence(\n            [elem.query_tensor for elem in elems],\n            padding_value=pad_token_id,\n            batch_first=True,\n        )\n    else:\n        raise ValueError(f\"Invalid padding side: {padding_side}\")"
        },
        {
            "comment": "This code pads tensors for elements in a list to match the standard tensor dimensions. It handles variable-length legal actions, action probabilities, and response tensors. If there's an error during padding, it prints the shape of the input tensors and the individual tensors.",
            "location": "\"/media/root/Toshiba XG3/works/LLM_Tree_Search/docs/src/tsllm/rl/data/buffer.py\":33-62",
            "content": "    for elem in elems:\n        # pad from [flexible_n_action, flexible_act_len] to [n_action, max_action_length]\n        elem.legal_actions_tensor = F.pad(\n            elem.legal_actions_tensor,\n            (\n                0,\n                max_action_length - elem.legal_actions_tensor.shape[1],\n                0,\n                max_num_actions - elem.legal_actions_tensor.shape[0],\n            ),\n            mode=\"constant\",\n            value=pad_token_id,\n        )\n        # pad from [flexible_n_action] to [n_action]\n        elem.action_probs = F.pad(\n            elem.action_probs,\n            (0, max_num_actions - elem.action_probs.shape[0]),\n            mode=\"constant\",\n            value=0.0,\n        )\n    try:\n        padded_response_tensor = pad_sequence(\n            [elem.response_tensor for elem in elems],\n            padding_value=pad_token_id,\n            batch_first=True,\n        )\n    except Exception as e:\n        print_with_rank([elem.response_tensor.shape for elem in elems])\n        print_with_rank([elem.response_tensor for elem in elems])"
        },
        {
            "comment": "This code is raising an exception 'e' if it occurs and then returns a MCTSBatch object containing various tensors including query_tensors, padded_response_tensor, rewards, values, returns, legal_actions_tensors, action_probs, terminated flags, and truncated flags.\n\nThe class MCTSBuffer is initialized with a list of TimeStep history, padding side, pad_token_id, max_action_length, and max_num_actions. It also returns the length of the history and pushes a sequence of TimeStep experiences into the history.",
            "location": "\"/media/root/Toshiba XG3/works/LLM_Tree_Search/docs/src/tsllm/rl/data/buffer.py\":63-91",
            "content": "        raise e\n    return MCTSBatch(\n        query_tensors,\n        # Right pad the rest, to have a single horizontal query/response split\n        padded_response_tensor,\n        torch.stack([elem.reward for elem in elems]),\n        torch.stack([elem.value for elem in elems]),\n        torch.stack([elem.returns for elem in elems]),\n        torch.stack([elem.legal_actions_tensor for elem in elems]),\n        torch.stack([elem.action_probs for elem in elems]),\n        torch.stack([elem.termiated for elem in elems]),\n        torch.stack([elem.truncated for elem in elems]),\n    )\nclass MCTSBuffer(Dataset):\n    def __init__(self, padding_side, pad_token_id, max_action_length, max_num_actions):\n        super().__init__()\n        self.history: List[TimeStep] = []\n        self.padding_side = padding_side\n        self.pad_token_id = pad_token_id\n        self.max_action_length = max_action_length\n        self.max_num_actions = max_num_actions\n    def __len__(self):\n        return len(self.history)\n    def push(self, exps: Sequence[TimeStep]):"
        },
        {
            "comment": "The code defines a class for managing and accessing data. It has methods to add experiences to the history, clear the history, get items from the history by index, and create a DataLoader object with specified batch size and shuffle option.",
            "location": "\"/media/root/Toshiba XG3/works/LLM_Tree_Search/docs/src/tsllm/rl/data/buffer.py\":92-116",
            "content": "        self.history += exps\n    def clear(self):\n        self.history = []\n    def __getitem__(self, index: int) -> TimeStep:\n        return self.history[index]\n    def create_loader(\n        self,\n        batch_size: int,\n        shuffle: bool,\n    ) -> DataLoader:\n        return DataLoader(\n            self,\n            batch_size,\n            shuffle=shuffle,\n            collate_fn=partial(\n                collate_fn,\n                self.padding_side,\n                self.pad_token_id,\n                self.max_action_length,\n                self.max_num_actions,\n            ),\n        )"
        }
    ]
}